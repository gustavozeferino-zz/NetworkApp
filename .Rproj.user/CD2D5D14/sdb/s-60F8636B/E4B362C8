{
    "contents" : "## Network App ##\n\nlibrary(\"shiny\")\nlibrary(\"devtools\")\nlibrary(\"ggplot2\")\nlibrary(\"huge\")\nlibrary(\"qgraph\")\nlibrary(\"psych\")\nlibrary(\"pcalg\")\n\ndata(bfi)\nbig5 <- bfi[,1:25]\n\nshinyServer(\n  function(input, output) {\n    ##############################\n    # Reactive variable defining #\n    ##############################\n    \n    # Define global data with estimation \n    data <- reactive({\n      \n      inFile <- input$input\n            \n      if(input$demo == TRUE)\n      {\n        file <- big5\n      } else \n      {\n        if (is.null(inFile))\n        {\n          return(NULL)\n        }\n        \n        # Code missing values\n        na <- NULL\n        if (input$missing == \"NA\")\n        {\n          na <- \"NA\"\n        }\n        else if (input$missing == FALSE)\n        {\n          na <- FALSE\n        }\n        else \n        {\n          na <- as.numeric(input$missing)\n        }\n        \n        file <- read.table(inFile$datapath, header=input$header, sep=input$sep, quote=input$quote, na.strings = na, stringsAsFactors = input$stringfactors, dec = input$decimal)\n      }\n      \n      \n    }) #exit data defining\n    \n    # Use chosen layout\n    lay <- reactive({\n      switch(input$layout,\n             \"Circle\" = \"circle\",\n             \"Spring\" = \"spring\",\n             \"Grouped Circle\" = \"groups\")\n    })\n    \n    lab <- reactive({\n      if(input$node_labels == TRUE)\n      {\n        names(data())\n      } else\n      {\n        FALSE\n      }     \n    })\n    \n    det <- reactive({\n      if(input$details == TRUE)\n      {\n        TRUE\n      } else\n      {\n        FALSE\n      }\n    })\n    \n    weight <- reactive ({\n      if(input$weighted == TRUE)\n      {\n        TRUE\n      } else\n      {\n        FALSE\n      }\n    })\n    \n    direct <- reactive({\n      if(input$direction == TRUE)\n      {\n        TRUE\n      } else\n      {\n        FALSE\n      }\n    })    \n    \n    tit <- reactive({\n      input$title     \n    })\n    \n    thres <- reactive({\n      input$threshold\n    })\n    \n    min <- reactive({\n      input$minimum \n    })\n    \n    max <- reactive({\n      input$maximum \n    })\n    \n    ct <- reactive({\n      input$cut})\n    \n    es <- reactive({\n      input$edgesize  \n    })\n    \n    ns <- reactive({\n      input$nodesize\n    })  \n    \n    past <- reactive({\n      input$pastelcol\n    })\n    \n    plotdiag <- reactive({\n      input$diagonal\n    })\n\n    FDRmeth <- reactive({\n      switch(input$FDRmethod,\n             \"local FDR\" = \"lfdr\", \n             \"p-value\" = \"pval\",\n             \"q-value\" = \"qval\")\n    })\n    \n    VARfam <- reactive({\n      switch(input$VARmethod,\n             \"Gaussian\" = \"gaussian\",\n             \"Binary\" = \"binomial\")\n    })\n  \n    \n    indeptest <- reactive({\n      switch(input$pcindep,\n             \"Binary\" = binCItest,\n             \"Discrete\" = disCItest,\n             \"D-separation\" = dsepTest,\n             \"Gaussian\" = gaussCItest)\n    })\n    \n    \n    norm <- reactive({\n      if(input$method == \"FDRnetwork\")\n      {       \n        if(input$normal == TRUE)\n        {\n          FDRnetwork(cor(huge.npn(data()), use = \"pairwise.complete.obs\"), cutoff = input$cutoffFDR, method = FDRmeth())\n        } else  \n        {\n          FDRnetwork(cor(data(), use = \"pairwise.complete.obs\"), cutoff = input$cutoffFDR, method = FDRmeth())\n        }  \n      } else if(input$method == \"VAR-model\")\n      {\n        \n        if(input$normal == TRUE)\n        {\n          VARglm(cor(huge.npn(data()), use = \"pairwise.complete.obs\"), family = VARfam())$graph \n        } else  \n        {\n          VARglm(cor(data(), use = \"pairwise.complete.obs\"), family = VARfam())$graph \n        }\n      } else if(input$method == \"IC-Algorithm: Skeleton\")\n      {\n        if(input$normal == TRUE)\n        {\n          skeleton(suffStat = list(C = cor(huge.npn(data()), use = \"pairwise.complete.obs\"), n = nrow(data())), indepTest = indeptest(), alpha = 0.05, labels = colnames(data()))\n        } else  \n        {\n          skeleton(suffStat = list(C = cor(data(), use = \"pairwise.complete.obs\"), n = nrow(data())), indepTest = indeptest(), alpha = 0.05, labels = colnames(data()))\n        }  \n      } else if(input$method == \"IC-Algorithm: DAG\")\n      {\n        if(input$normal == TRUE)\n        {\n          pc(suffStat = list(C = cor(huge.npn(data()), use = \"pairwise.complete.obs\"), n = nrow(data())), indepTest = indeptest(), alpha = 0.05, labels = colnames(data()))\n        } else  \n        {\n          pc(suffStat = list(C = cor(data(), use = \"pairwise.complete.obs\"), n = nrow(data())), indepTest = indeptest(), alpha = 0.05, labels = colnames(data()))\n        } \n      } else  \n        {\n          if(input$normal == TRUE)\n          {\n            cor(huge.npn(data()), use = \"pairwise.complete.obs\")\n          } else  \n          {\n            cor(data(), use = \"pairwise.complete.obs\")\n          }\n        }\n    })\n    \n    est <- reactive({\n      if(!input$method == \"FDRnetwork\")\n      {\n        switch(input$method,\n               \"GLASSO\" = \"glasso\",\n               \"Pearson Correlation\" = \"cor\",\n               \"Partial Correlation\" = \"pcor\") \n      }         \n    })\n\n    shapenode <- reactive({\n      switch(input$nodeshape,\n             \"Circle\" = \"circle\",\n             \"Diamond\" = \"diamond\",\n             \"Heart\" = \"heart\",\n             \"Square\" = \"square\",\n             \"Triangle\" = \"triangle\")\n    })\n      \n    # Visualize network\n    output$network <- renderPlot({       \n      \n      #visualize network\n      if(is.null(data()))\n      {\n        return(NULL)\n      } else if(input$sortdata == \"Raw Data\")\n      {\n          qgraph(norm(),\n                 layout = lay(), \n                 labels = lab(),\n                 title = tit(),\n                 minimum = min(),\n                 maximum = max(),\n                 cut = ct(),\n                 details = det(),\n                 esize = es(),\n                 vsize = ns(),\n                 weighted = weight(),\n                 directed = direct(),\n                 sampleSize = nrow(data()),\n                 graph = est(),\n                 threshold = thres(),\n                 shape = shapenode(),\n                 diag = plotdiag())\n      } else if(input$sortdata == \"Adjacency Matrix\")\n      {\n        qgraph(data(),\n               layout = lay(), \n               labels = lab(),\n               title = tit(),\n               minimum = min(),\n               maximum = max(),\n               cut = ct(),\n               details = det(),\n               esize = es(),\n               vsize = ns(),\n               weighted = weight(),\n               directed = direct(),\n               threshold = thres(),\n               shape = shapenode(),\n               pastel = past(),\n               diag = plotdiag())\n      } else if(input$sortdata == \"Edgelist\")\n      {\n        qgraph(data(),\n               layout = lay(), \n               labels = lab(),\n               title = tit(),\n               minimum = min(),\n               maximum = max(),\n               cut = ct(),\n               details = det(),\n               esize = es(),\n               vsize = ns(),\n               weighted = weight(),\n               directed = direct(),\n               threshold = thres(),\n               shape = shapenode(),\n               pastel = past(),\n               diag = plotdiag())\n      }\n    }, width = \"auto\", height = 500) #exit visualizing network \n    \n    #download network image\n    output$downloadnetwork <- downloadHandler(\n      filename = function()\n      {\n        paste(\"network\", class = \".pdf\", sep = \"\") \n      },\n      content = function(file) \n      {\n        pdf(file)\n       if(input$sortdata == \"Raw Data\")\n      {\n        qgraph(norm(),\n               layout = lay(), \n               labels = lab(),\n               title = tit(),\n               minimum = min(),\n               maximum = max(),\n               cut = ct(),\n               details = det(),\n               esize = es(),\n               vsize = ns(),\n               weighted = weight(),\n               directed = direct(),\n               sampleSize = nrow(data()),\n               graph = est(),\n               threshold = thres(),\n               shape = shapenode(),\n               pastel = past(),\n               diag = plotdiag())\n      } else if(input$sortdata == \"Adjacency Matrix\")\n      {\n        qgraph(data(),\n               layout = lay(), \n               labels = lab(),\n               title = tit(),\n               minimum = min(),\n               maximum = max(),\n               cut = ct(),\n               details = det(),\n               esize = es(),\n               vsize = ns(),\n               weighted = weight(),\n               directed = direct(),\n               threshold = thres(),\n               shape = shapenode(),\n               pastel = past(),\n               diag = plotdiag())\n      } else if(input$sortdata == \"Edgelist\")\n      {\n        qgraph(data(),\n               layout = lay(), \n               labels = lab(),\n               title = tit(),\n               minimum = min(),\n               maximum = max(),\n               cut = ct(),\n               details = det(),\n               esize = es(),\n               vsize = ns(),\n               weighted = weight(),\n               directed = direct(),\n               threshold = thres(),\n               shape = shapenode(),\n               pastel = past(),\n               diag = plotdiag())\n      }\n        dev.off()\n      }) #exit download network plot\n    \n    # Download example dataset\n    exampledata <- reactive({\n      bfi[,1:25]\n    })\n    \n    output$downloadexample <- downloadHandler(\n      filename = function()\n      {\n        paste(\"bfi\", class = \".csv\", sep = \"\") \n      },\n      content = function(file) \n      {\n        write.csv(exampledata(), file)\n      }) #exit download example dataset\n    \n    # Set centrality measures for plot\n    stren <- reactive({\n      if(input$sortdata == \"Raw Data\")\n      {\n        if(input$strength == TRUE)\n        {\n          \"Strength\"\n        }\n      } \n    })\n    \n    between <- reactive({\n      if(input$betweenness == TRUE)\n      {\n        \"Betweenness\"\n      }\n    })\n    \n    close <- reactive({\n      if(input$closeness == TRUE)\n      {\n        \"Closeness\"\n      }\n    })\n    \n    indeg <- reactive({\n      if(input$sortdata == \"Adjacency Matrix\" | input$sortdata == \"Edgelist\")\n      {\n        if(input$indegree == TRUE)\n        {\n          \"InDegree\"\n        }\n      }\n    })\n    \n    outdeg <- reactive({\n      if(input$sortdata == \"Adjacency Matrix\" | input$sortdata == \"Edgelist\")\n      {\n        if(input$outdegree == TRUE)\n        {\n          \"OutDegree\"\n        }\n      }\n    })\n    \n    # Print centrality plot\n    output$centplot <- renderPlot({\n      \n      # Plot centrality results\n      if(input$sortdata == \"Raw Data\")\n      {\n        cent <- centralityPlot(qgraph(norm(),\n               sampleSize = nrow(data()),\n               graph = est(),\n               weighted = weight(),\n               directed = direct(), \n               DoNotPlot = TRUE), include = c(stren(), between(), close()))\n      } else if(input$sortdata == \"Adjacency Matrix\")\n      {\n        cent <- centralityPlot(qgraph(data(),\n                                      weighted = weight(),\n                                      directed = direct(),\n                                      DoNotPlot = TRUE), include = c(between(), close(), indeg(), outdeg()))\n      } else if(input$sortdata == \"Edgelist\")\n      {\n        cent <- centralityPlot(qgraph(data(),\n                                      weighted = weight(),\n                                      directed = direct(),\n                                      DoNotPlot = TRUE), include = c(between(), close(), indeg(), outdeg()))\n      }\n      \n      # Flip plot if chosen\n      if(input$horizontal == TRUE)\n      {\n        print(cent + theme(axis.text.x = element_text(size = 5, angle = 45, hjust = 1, vjust = 1)) + coord_flip())\n      } else\n      {\n        print(cent)\n      }\n    }) # exit centrality plot  \n    \n    # Download centrality plot\n    output$downloadcentralityplot <- downloadHandler(\n      \n      filename = function()\n      {\n        paste(\"centrality_plot\", class = \".pdf\", sep = \"\") \n      },\n      content = function(file) \n      {\n        if(input$horizontal == TRUE)\n        {\n          pdf(file)\n          if(input$sortdata == \"Raw Data\")\n          {\n            g <- centralityPlot(qgraph(norm(),\n                                      sampleSize = nrow(data()),\n                                       graph = est(),\n                                       weighted = weight(),\n                                       directed = direct(),\n                                      DoNotPlot = TRUE), print = FALSE, include = c(stren(), between(), close(), indeg())) + theme(axis.text.x = element_text(size = 5, angle = 45, hjust = 1, vjust = 1)) + coord_flip()\n          } else if(input$sortdata == \"Adjacency Matrix\")\n          {\n            g <- centralityPlot(qgraph(data(), \n                                       weighted = weight(),\n                                       directed = direct(),\n                                       DoNotPlot = TRUE), print = FALSE, include = c(stren(), between(), close(), indeg())) + theme(axis.text.x = element_text(size = 5, angle = 45, hjust = 1, vjust = 1)) + coord_flip()\n          } else if(input$sortdata == \"Edgelist\")\n          {\n            g <- centralityPlot(qgraph(data(), \n                                       weighted = weight(),\n                                       directed = direct(),\n                                       DoNotPlot = TRUE), print = FALSE, include = c(stren(), between(), close(), indeg())) + theme(axis.text.x = element_text(size = 5, angle = 45, hjust = 1, vjust = 1)) + coord_flip()\n          }\n          print(g)\n          dev.off()\n        } else\n        {\n          pdf(file)\n          if(input$sortdata == \"Raw Data\")\n          {\n            g <- centralityPlot(qgraph(norm(),\n                                       sampleSize = nrow(data()),\n                                       graph = est(),\n                                       weighted = weight(),\n                                       directed = direct(),\n                                       DoNotPlot = TRUE), print = FALSE, include = c(stren(), between(), close(), indeg())) + theme(axis.text.x = element_text(size = 5, angle = 45, hjust = 1, vjust = 1))\n          } else if(input$sortdata == \"Adjacency Matrix\")\n          {\n            g <- centralityPlot(qgraph(data(),\n                                       weighted = weight(),\n                                       directed = direct(),\n                                       DoNotPlot = TRUE), print = FALSE, include = c(stren(), between(), close(), indeg())) + theme(axis.text.x = element_text(size = 5, angle = 45, hjust = 1, vjust = 1))\n          } else if(input$sortdata == \"Edgelist\")\n          {\n            g <- centralityPlot(qgraph(data(),\n                                       weighted = weight(),\n                                       directed = direct(),\n                                       DoNotPlot = TRUE), print = FALSE, include = c(stren(), between(), close(), indeg())) + theme(axis.text.x = element_text(size = 5, angle = 45, hjust = 1, vjust = 1))\n          }\n          print(g)\n          dev.off()\n        }\n\n      }) #exit download centrality plot  \n    \n    # Set centrality measures for table\n    strentab <- reactive({\n      if(input$strengthtab == TRUE)\n      {\n        \"Strength\"\n      }\n    })\n    \n    betweentab <- reactive({\n      if(input$betweennesstab == TRUE)\n      {\n        \"Betweenness\"\n      }\n    })\n    \n    closetab <- reactive({\n      if(input$closenesstab == TRUE)\n      {\n        \"Closeness\"\n      }\n    })\n\n    \n    centtable <- reactive({  \n      ncol <- rep(FALSE, times = 10)\n      \n      ncol[2] = TRUE\n      if(input$sortdata == \"Raw Data\")\n      {\n        if(input$strengthtab == TRUE)\n        {\n          ncol[8] = TRUE\n        }\n      }\n      if(input$betweennesstab == TRUE)\n      {\n        ncol[4] = TRUE\n      }\n      if(input$closenesstab == TRUE)\n      {\n        ncol[6] = TRUE\n      }\n      if(input$sortdata == \"Adjacency Matrix\" | input$sortdata == \"Edgelist\")\n      {\n        if(input$indegreetab == TRUE)\n        {\n          ncol[8] = TRUE\n        }      \n      }\n      if(input$sortdata == \"Adjacency Matrix\" | input$sortdata == \"Edgelist\")\n      {\n        if(input$outdegreetab == TRUE)\n        {\n          ncol[10] = TRUE\n        }\n      }\n      \n      \n      centtab <- reactive({\n        if(input$sortdata == \"Raw Data\")\n        {\n          centralityTable(qgraph(norm(),\n                                     sampleSize = nrow(data()),\n                                     graph = est(),\n                                     weighted = weight(),\n                                     directed = direct(),\n                                     DoNotPlot = TRUE))\n        } else if(input$sortdata == \"Adjacency Matrix\")\n        {\n          centralityTable(qgraph(data(),\n                                     weighted = weight(),\n                                     directed = direct(),\n                                     DoNotPlot = TRUE))\n        } else if(input$sortdata == \"Edgelist\")\n        {\n          centralityTable(qgraph(data(),\n                                     weighted = weight(),\n                                     directed = direct(),\n                                     DoNotPlot = TRUE))\n        }\n      })\n     \n      reshape(centtab(), timevar = \"measure\",\n              idvar = c(\"graph\", \"node\"),\n              direction = \"wide\")[, ncol]\n      \n\n    }) #exit centrality table (global variable)\n    \n    # Print centrality table\n    output$centtable <- renderTable({\n      print(centtable())\n    }) #exit centrality table \n    \n    output$downloadcentralitytable <- downloadHandler(            \n      filename = function()\n      {\n        paste(\"centrality_table\", class = \".csv\", sep = \"\") \n      },            \n      content = function(file) \n      {\n        write.csv(centtable(), file, row.names = FALSE)\n      }) #exit download centrality table\n    \n    # Set clustering measures for plot\n    wes <- reactive({\n      if(input$ws == TRUE)\n      {\n        \"WS\"\n      }\n    })\n    \n    zh <- reactive({\n      if(input$zhang == TRUE)\n      {\n        \"Zhang\"\n      }\n    })\n    \n    onn <- reactive({\n      if(input$onnela == TRUE)\n      {\n        \"Onnela\"\n      }\n    })\n    \n    bar <- reactive({\n      if(input$barrat == TRUE)\n      {\n        \"Barrat\"\n      }\n      \n    })\n    \n    # Print clustering plot\n    output$clustplot <- renderPlot({\n      \n      # Plot clustering measures    \n      if(input$sortdata == \"Raw Data\")\n      {\n        c <- clusteringPlot(qgraph(norm(),\n                                   layout = lay(), \n                                   labels = lab(),\n                                   title = tit(),\n                                   minimum = min(),\n                                   maximum = max(),\n                                   cut = ct(),\n                                   details = det(),\n                                   esize = es(),\n                                   vsize = ns(),\n                                   weighted = weight(),\n                                   directed = direct(),\n                                   sampleSize = nrow(data()),\n                                   graph = est(),\n                                   DoNotPlot = TRUE), include = c(wes(), zh(), onn(), bar()))\n      } else if(input$sortdata == \"Adjacency Matrix\")\n      {\n        c <- clusteringPlot(qgraph(data(),\n                                   layout = lay(), \n                                   labels = lab(),\n                                   title = tit(),\n                                   minimum = min(),\n                                   maximum = max(),\n                                   cut = ct(),\n                                   details = det(),\n                                   esize = es(),\n                                   vsize = ns(),\n                                   weighted = weight(),\n                                   directed = direct(),\n                                   DoNotPlot = TRUE), include = c(wes(), zh(), onn(), bar()))\n      } else if(input$sortdata == \"Edgelist\")\n      {\n        c <- clusteringPlot(qgraph(data(),\n                                   layout = lay(), \n                                   labels = lab(),\n                                   title = tit(),\n                                   minimum = min(),\n                                   maximum = max(),\n                                   cut = ct(),\n                                   details = det(),\n                                   esize = es(),\n                                   vsize = ns(),\n                                   weighted = weight(),\n                                   directed = direct(),\n                                   DoNotPlot = TRUE), include = c(wes(), zh(), onn(), bar()))\n      }\n      \n      # Flip plot if chosen\n      if(input$horizontal == TRUE)\n      {\n        print(c + coord_flip() + theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)))\n      } else\n      {\n        print(c)\n      }\n    }) # exit centrality plot  \n    \n    # Download clustering plot\n    output$downloadclusteringplot <- downloadHandler(\n      \n      filename = function()\n      {\n        paste(\"clustering_plot\", class = \".pdf\", sep = \"\") \n      },\n      content = function(file) \n      {\n        pdf(file)\n        if(input$sortdata == \"Raw Data\")\n        {\n          clusteringPlot(qgraph(norm(),\n                                     layout = lay(), \n                                     labels = lab(),\n                                     title = tit(),\n                                     minimum = min(),\n                                     maximum = max(),\n                                     cut = ct(),\n                                     details = det(),\n                                     esize = es(),\n                                     vsize = ns(),\n                                     weighted = weight(),\n                                     directed = direct(),\n                                     sampleSize = nrow(data()),\n                                     graph = est(),\n                                     DoNotPlot = TRUE), include = c(wes(), zh(), onn(), bar()))\n        } else if(input$sortdata == \"Adjacency Matrix\")\n        {\n          clusteringPlot(qgraph(data(),\n                                     layout = lay(), \n                                     labels = lab(),\n                                     title = tit(),\n                                     minimum = min(),\n                                     maximum = max(),\n                                     cut = ct(),\n                                     details = det(),\n                                     esize = es(),\n                                     vsize = ns(),\n                                     weighted = weight(),\n                                     directed = direct(),\n                                     DoNotPlot = TRUE), include = c(wes(), zh(), onn(), bar()))\n        } else if(input$sortdata == \"Edgelist\")\n        {\n          clusteringPlot(qgraph(data(),\n                                     layout = lay(), \n                                     labels = lab(),\n                                     title = tit(),\n                                     minimum = min(),\n                                     maximum = max(),\n                                     cut = ct(),\n                                     details = det(),\n                                     esize = es(),\n                                     vsize = ns(),\n                                     weighted = weight(),\n                                     directed = direct(),\n                                     DoNotPlot = TRUE), include = c(wes(), zh(), onn(), bar()))\n        }\n        dev.off()\n      })     #exit download clustering plot  \n    \n    clusttable <- reactive({  \n      ncol <- rep(FALSE, times = 10)\n      \n      ncol[2] = TRUE\n      if(input$wstab == TRUE)\n      {\n        ncol[4] = TRUE\n      }\n      if(input$zhangtab == TRUE)\n      {\n        ncol[6] = TRUE\n      }\n      if(input$onnelatab == TRUE)\n      {\n        ncol[8] = TRUE\n      }\n      if(input$barrattab == TRUE)\n      {\n        ncol[10] = TRUE\n      }\n      \n      clusttab <- reactive({\n        if(input$sortdata == \"Raw Data\")\n        {\n          clusteringTable(qgraph(norm(),\n                                 layout = lay(), \n                                 labels = lab(),\n                                 title = tit(),\n                                 minimum = min(),\n                                 maximum = max(),\n                                 cut = ct(),\n                                 details = det(),\n                                 esize = es(),\n                                 vsize = ns(),\n                                 weighted = weight(),\n                                 directed = direct(),\n                                 sampleSize = nrow(data()),\n                                 graph = est(),\n                                 DoNotPlot = TRUE))\n        } else if(input$sortdata == \"Adjacency Matrix\")\n        {\n          clusteringTable(qgraph(data(),\n                                 layout = lay(), \n                                 labels = lab(),\n                                 title = tit(),\n                                 minimum = min(),\n                                 maximum = max(),\n                                 cut = ct(),\n                                 details = det(),\n                                 esize = es(),\n                                 vsize = ns(),\n                                 weighted = weight(),\n                                 directed = direct(),\n                                 DoNotPlot = TRUE))\n        } else if(input$sortdata == \"Edgelist\")\n        {\n          clusteringTable(qgraph(data(),\n                                 layout = lay(), \n                                 labels = lab(),\n                                 title = tit(),\n                                 minimum = min(),\n                                 maximum = max(),\n                                 cut = ct(),\n                                 details = det(),\n                                 esize = es(),\n                                 vsize = ns(),\n                                 weighted = weight(),\n                                 directed = direct(),\n                                 DoNotPlot = TRUE))\n        }\n      })\n      \n      \n      reshape(clusttab(), timevar = \"measure\",\n              idvar = c(\"graph\", \"node\"),\n              direction = \"wide\")[, ncol]\n    }) #exit clustering table (global variable)\n    \n    # Print clustering table\n    output$clusttable <- renderTable({\n      print(clusttable())\n    }) #exit clustering table \n    \n    output$downloadclusteringtable <- downloadHandler(            \n      filename = function()\n      {\n        paste(\"clustering_table\", class = \".csv\", sep = \"\") \n      },            \n      content = function(file) \n      {\n        write.csv(clusttable(), file, row.names = FALSE)\n      }) #exit download clustering table\n  }) #exit shinyserver\n\n",
    "created" : 1429785267370.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3031411929",
    "id" : "E4B362C8",
    "lastKnownWriteTime" : 1427194256,
    "path" : "~/GitHub/NetworkApp/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}